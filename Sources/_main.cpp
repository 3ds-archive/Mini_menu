// ----------------------------------------------------------------- //
//                                                                   //
//             /!\      DO NOT EDIT THIS FILE!       /!\             //
//                                                                   //
// ----------------------------------------------------------------- //
#include "cheats.hpp"
#include "plugin.hpp"
#include "csvc.h"

extern "C" unsigned char *NTR_Fonts;
extern "C" unsigned char *Background;

constexpr auto ENTRY_MAX = 500;

struct S_ITEM
{
	std::string		name, note;
	bool			enabled, opened;
	Fptr			cheat;
	int				type;
	int				radio;
	int				f_index;
};
std::vector<S_ITEM> entries;
int radio_n[100];
int selector;
u32 MenuOpenHotkey = Select;
bool MenuOpened;
int menu_mode;// 0=cheats, 1=menu's hotkey, 2=speed

void new_entry(const std::string& name, Fptr cheat)
{
	entries.push_back({ name, "", 0, 0, cheat, 0, -1, -1 });
}

void new_entry_with_note(const std::string& name, const std::string& note, Fptr cheat)
{
	entries.push_back({ name, note, 0, 0, cheat, 0, -1, -1 });
}

void new_radio_entry(int group, const std::string& name, Fptr cheat)
{
	entries.push_back({ name, "", 0, 0, cheat, 0, group, -1 });
}

void new_radio_entry_with_note(int group, const std::string& name, const std::string& note, Fptr cheat)
{
	entries.push_back({ name, note, 0, 0, cheat, 0, group, -1 });
}

void new_spoiler(const std::string& name)
{
	entries.push_back({ name, "", 0, 0, nullptr, 1, -1, -1 });
}

void new_spoiler_with_note(const std::string& name, const std::string& note)
{
	entries.push_back({ name, note, 0, 0, nullptr, 1, -1, -1 });
}

void exit_spoiler()
{
	S_ITEM item{ "", "", 0, 0, nullptr, 2, -1, -1 };
	int i = entries.size(), c = 0;
	entries.push_back(item);
	while (true)
	{
		if (entries[i].type == 2)c++;
		if (entries[i].type == 1)c--;
		if (c == 0) break;
		i--;
	}
	entries[entries.size() - 1].f_index = i;
}

void DrawChar(const Screen &scr, u8 letter, int x, int y, Color cc)
{
	int i;
	int k;
	int c;
	unsigned char mask;
	unsigned char* _letter;
	unsigned char l; 
	
	//if ((letter < 32) || (letter > 127)) letter = '?';
	if ((letter < 32) || (letter > 127)) return;
	
	c=(letter-32)*8;
	for (i = 0; i < 8; i++)
	{
		mask = 0b10000000;
		l = NTR_Fonts[i+c];
		for (k = 0; k < 8; k++)
		{
			if ((mask >> k) & l)
				scr.DrawPixel(x+k, y+i, cc);
		}
	}
}

void DrawString(const Screen &scr, const std::string &str, int x, int y, Color c)
{
	for (int i = 0; i < str.length(); i++)
		DrawChar(scr, str[i], x + i * 8, y, c);
}

inline void DrawBackground(const Screen &scr)
{
	scr.DrawRect(0, 0, 320, 240, Color(0, 0, 90));
}

// --------------------------------------------
// メニュー描画
// --------------------------------------------
void DrawMenu(const Screen &scr)
{
	// background
	/*
	int offs;
	for( int x = 0; x < 320; x++ )
		for( int y = 0; y < 240; y++ )
		{
			offs = (x + y * 320) * 3;
			scr.DrawPixel(x, y, Color( Background[offs+2], Background[offs+1], Background[offs] ));
		}
	*/
	
	//u8 *fb = scr.GetFramebuffer(0, 0); //gfxGetFramebuffer(GFX_BOTTOM, GFX_LEFT, nullptr, nullptr);
	//memcpy(fb, Background, 240*320*3);
	DrawBackground(scr);
	
	std::string menu_mode_str;
	
	if( menu_mode == 0 )
		menu_mode_str = "Cheats Menu";
	
	scr.DrawSysfont(menu_mode_str, 160-OSD::GetTextWidth(true, menu_mode_str)/2, 8);
	
	int dy = 38, px = 0;
	for (int i = 0; i <= (entries.size() - 1) * entries[0].enabled; i++)
	{
		S_ITEM& item = entries[i];
		
		if (i == 1)
		{
			DrawString(scr, "----------------------", 10, dy, Color::Gray);
			dy += 10;
		}
		
		// エントリー名描画
		if (item.type < 2)
		{
			std::string str(item.name);
			if (item.type == 1)
				if (item.opened)
					str = "[- " + item.name + " -]";
				else
					str = "[+ " + item.name + " +]";
			
			// 選んでるとこのエントリー名の背景を白くする
			if( selector == i )
				scr.DrawRect(10+px*8-1, dy, str.length() * 8 + 1, 10, Color::White);
			
			// 
			DrawString(scr, str, 10 + px * 8, dy+1, selector==i ? 0 : Color::White);
			
			// フォルダの場合はオレンジ色で描画
			if( item.type==1 && selector != i )
				DrawString(scr, item.name, 10 + px*8+24, dy+1, Color(255, 110, 0));
			
			// ON/OFF
			if( item.type == 0 )
				DrawString( scr, std::string("ON OFFYESNO ").substr((i==0)*6+(!item.enabled)*3, 3), 290, dy, item.enabled ? Color(0,255,0) : (i==0 ? Color::Red : Color::White) );
			
			dy += 10;
		}
		
		if (item.type == 1 && !item.opened)
		{
			for (int c = 0;;)
			{
				if (entries[i].type == 1) c++;
				if (entries[i].type == 2) c--;
				if (c == 0) break;
				i++;
			}
		}
		
		if (entries[i].type == 1) px++;
		if (item.type == 2) px--;
	}
	
}

// --------------------------------------------
// メニュー更新，操作
// --------------------------------------------
void Update()
{
	static Clock clock;
	
	for (int i = 0; i < entries.size(); i++)
	{
		S_ITEM& s = entries[i];
		if (s.radio > -1 && radio_n[s.radio] != i && s.enabled)
			s.enabled = false;
	}
	
	// Close menu
	if ( Controller::IsKeyPressed(B) )
		MenuOpened = false;
	
	// Press A
	if ( Controller::IsKeyPressed(A) )
	{
		// folder
		if (entries[selector].type == 1)
		{
			bool &b = entries[selector].opened; b = !b;
			if (b)
			{
				for (int i = selector + 1; i < entries.size(); i++)
					if (entries[i].type == 1)entries[i].opened = false;

				for (int i = 0; i < selector; i++)
					if (entries[i].type == 2) entries[entries[i].f_index].opened = false;
			}
		}

		// entry
		else if (entries[selector].type == 0)
		{
			bool& b = entries[selector].enabled; b = !b;
			if (entries[selector].radio >= 0)
				radio_n[entries[selector].radio] = selector;
		}
	}
	
	// Up
	if ((Controller::IsKeyPressed(DPadUp) || (Controller::IsKeyDown(DPadUp) && clock.HasTimePassed(Milliseconds(100)))) && entries[0].enabled)
	{
		do
		{
			selector -= 1;
			if (selector < 0) selector = entries.size() - 1;
			if (selector > 0 && selector < entries.size() && entries[selector].type == 2 && !entries[entries[selector].f_index].opened)
			{
				for (int c = 0;;)
				{
					if (entries[selector].type == 2) c++;
					if (entries[selector].type == 1) c--;
					if (c == 0) break;
					selector--;
				}
			}
		} while (entries[selector].type == 2);
		
		clock.Restart();
	}
	
	// Down
	else if ((Controller::IsKeyPressed(DPadDown) || (Controller::IsKeyDown(DPadDown) && clock.HasTimePassed(Milliseconds(100)))) && entries[0].enabled)
	{
		if (selector >= 0 && entries[selector].type == 1 && !entries[selector].opened)
		{
			for (int c = 0;;)
			{
				if (entries[selector].type == 1) c++;
				if (entries[selector].type == 2) c--;
				if (c == 0) break;
				selector++;
			}
		}

		selector++;
		while (entries[selector].type == 2)
			selector++;
		if (selector >= entries.size()) selector = 0;
		
		clock.Restart();
	}
}

extern const char *Creater_name;
void DrawWelcomeScreen(const Screen &scr)
{
	int px = 36, py = 34;
	
	Color c1(65, 135, 152);
	Color c2(107, 202, 226);
	Color c3(238, 147, 0);
	Color c4(0, 255, 0);
	
	const Color msg_c[] = {c1, c2, c2, c1, 0, c3, c3, 0, c1, 0, c4, 0 , c1, c2, c2, c2, c2};
	
	//const std::vector<std::string> messages =
	char const* messages[] =
	{
		"------------------------------",
		"  Created using libShark2NTR",
		"         by Nanquitas",
		"------------------------------",
		"",
		" This plugin is brought to you",
		//"         by " + std::string(Creater_name),
		"         by ",
		"",
		"------------------------------",
		"",
		"  Press A to access the menu",
		"",
		"------------------------------",
		"  Keys:",
		"  [Y]: Show the cheat's note",
		"  [Select]: Speed menu",
		"  [Start]: Hotkeys menu",
	};
	
	DrawBackground(scr);

	for(size_t i=0;i<sizeof(messages)/sizeof(char*);i++){
		std::string&& s = messages[i];

		if( i==6 ) { s += Creater_name; }

		DrawString(scr, s, px, py, msg_c[i]);
		py += 10;
	}
}

void my_menus();

namespace CTRPluginFramework
{
	int main(void)
	{
		new_entry("Cheats enabled", nullptr);
		my_menus();
		
		while( aptMainLoop() )
		{
			Sleep(Milliseconds(16));
			Controller::Update();
			if( Controller::IsKeyPressed(Select) ) break;
		}
		
		// show welcome screen
		Process::Pause();
		const Screen &scr = OSD::GetBottomScreen();
		while( true )
		{
			Controller::Update();
			if( Controller::IsKeyPressed(A) || Controller::IsKeyPressed(B) ) goto menu;
			DrawWelcomeScreen(scr);
			OSD::SwapBuffers();
		}
		
		while( aptMainLoop() )
		{
			Sleep(Milliseconds(16));
			Controller::Update();
			
			// run enabled cheats
			if( entries[0].enabled )
				for( S_ITEM &item : entries )
					if( item.type == 0 && item.enabled && item.cheat != nullptr ) item.cheat();
			
			if( Controller::IsKeysPressed( MenuOpenHotkey ) )
			{
				Process::Pause();
				
			menu:
				const Screen &scr = OSD::GetBottomScreen();
				
				menu_mode = 0;
				MenuOpened = true;
				while (MenuOpened)
				{
					Controller::Update();
					DrawMenu(scr);
					Update();
					OSD::SwapBuffers();
				}
				
				Process::Play();
			}
		}
		
		return 0;
	}
}


